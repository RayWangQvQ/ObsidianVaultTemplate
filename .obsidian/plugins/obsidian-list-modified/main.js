/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => ListModified
});
var import_obsidian13 = __toModule(require("obsidian"));

// src/io/settingsTab.ts
var import_obsidian9 = __toModule(require("obsidian"));

// src/constants.ts
var DEFAULT_SETTINGS = {
  tags: "",
  excludedFolders: "",
  ignoredNameContains: "",
  outputFormat: "- [[link]]",
  appendSpaceAfterHeadings: false,
  timeFormat: "YYYY-MM-DD",
  autoCreateLogNote: true,
  logNoteType: "daily",
  writeInterval: 0,
  autoCreatePrimaryHeading: true,
  primaryHeading: "Changed Notes",
  modifiedHeading: "Modified",
  separateCreated: false,
  createdHeading: "Created",
  separateDeleted: false,
  deletedHeading: "Deleted",
  lastTrackedDate: "",
  trackedFiles: [],
  verboseModeEnabled: false
};

// src/utils/formatter.ts
var import_obsidian8 = __toModule(require("obsidian"));

// obsidian-daily-notes-interface-fork/constants.ts
var DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
var DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
var DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
var DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
var DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";

// obsidian-daily-notes-interface-fork/settings.ts
function shouldUsePeriodicNotesSettings(periodicity) {
  var _a, _b;
  const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
  return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a[periodicity]) == null ? void 0 : _b.enabled);
}
function getDailyNoteSettings() {
  var _a, _b, _c, _d;
  try {
    const { internalPlugins, plugins } = window.app;
    if (shouldUsePeriodicNotesSettings("daily")) {
      const { format: format2, folder: folder2, template: template2 } = ((_b = (_a = plugins.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.daily) || {};
      return {
        format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
        folder: (folder2 == null ? void 0 : folder2.trim()) || "",
        template: (template2 == null ? void 0 : template2.trim()) || ""
      };
    }
    const { folder, format, template } = ((_d = (_c = internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _c.instance) == null ? void 0 : _d.options) || {};
    return {
      format: format || DEFAULT_DAILY_NOTE_FORMAT,
      folder: (folder == null ? void 0 : folder.trim()) || "",
      template: (template == null ? void 0 : template.trim()) || ""
    };
  } catch (err) {
    console.info("No custom daily note settings found!", err);
  }
}
function getWeeklyNoteSettings() {
  var _a, _b, _c, _d, _e, _f, _g;
  try {
    const pluginManager = window.app.plugins;
    const calendarSettings = (_a = pluginManager.getPlugin("calendar")) == null ? void 0 : _a.options;
    const periodicNotesSettings = (_c = (_b = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _b.settings) == null ? void 0 : _c.weekly;
    if (shouldUsePeriodicNotesSettings("weekly")) {
      return {
        format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
        folder: ((_d = periodicNotesSettings.folder) == null ? void 0 : _d.trim()) || "",
        template: ((_e = periodicNotesSettings.template) == null ? void 0 : _e.trim()) || ""
      };
    }
    const settings2 = calendarSettings || {};
    return {
      format: settings2.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
      folder: ((_f = settings2.weeklyNoteFolder) == null ? void 0 : _f.trim()) || "",
      template: ((_g = settings2.weeklyNoteTemplate) == null ? void 0 : _g.trim()) || ""
    };
  } catch (err) {
    console.info("No custom weekly note settings found!", err);
  }
}
function getMonthlyNoteSettings() {
  var _a, _b, _c, _d;
  const pluginManager = window.app.plugins;
  try {
    const settings2 = shouldUsePeriodicNotesSettings("monthly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.monthly) || {};
    return {
      format: settings2.format || DEFAULT_MONTHLY_NOTE_FORMAT,
      folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
      template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
    };
  } catch (err) {
    console.info("No custom monthly note settings found!", err);
  }
}
function getQuarterlyNoteSettings() {
  var _a, _b, _c, _d;
  const pluginManager = window.app.plugins;
  try {
    const settings2 = shouldUsePeriodicNotesSettings("quarterly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.quarterly) || {};
    return {
      format: settings2.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
      folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
      template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
    };
  } catch (err) {
    console.info("No custom quarterly note settings found!", err);
  }
}
function getYearlyNoteSettings() {
  var _a, _b, _c, _d;
  const pluginManager = window.app.plugins;
  try {
    const settings2 = shouldUsePeriodicNotesSettings("yearly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.yearly) || {};
    return {
      format: settings2.format || DEFAULT_YEARLY_NOTE_FORMAT,
      folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
      template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
    };
  } catch (err) {
    console.info("No custom yearly note settings found!", err);
  }
}

// obsidian-daily-notes-interface-fork/daily.ts
var import_obsidian2 = __toModule(require("obsidian"));

// obsidian-daily-notes-interface-fork/vault.ts
var import_obsidian = __toModule(require("obsidian"));
function join(...partSegments) {
  let parts = [];
  for (let i = 0, l = partSegments.length; i < l; i++) {
    parts = parts.concat(partSegments[i].split("/"));
  }
  const newParts = [];
  for (let i = 0, l = parts.length; i < l; i++) {
    const part = parts[i];
    if (!part || part === ".")
      continue;
    else
      newParts.push(part);
  }
  if (parts[0] === "")
    newParts.unshift("");
  return newParts.join("/");
}
function ensureFolderExists(path) {
  return __async(this, null, function* () {
    const dirs = path.replace(/\\/g, "/").split("/");
    dirs.pop();
    if (dirs.length) {
      const dir = join(...dirs);
      if (!window.app.vault.getAbstractFileByPath(dir)) {
        yield window.app.vault.createFolder(dir);
      }
    }
  });
}
function getNotePath(directory, filename) {
  return __async(this, null, function* () {
    if (!filename.endsWith(".md")) {
      filename += ".md";
    }
    const path = (0, import_obsidian.normalizePath)(join(directory, filename));
    yield ensureFolderExists(path);
    return path;
  });
}
function getTemplateInfo(template) {
  return __async(this, null, function* () {
    const { metadataCache, vault } = window.app;
    const templatePath = (0, import_obsidian.normalizePath)(template);
    if (templatePath === "/") {
      return Promise.resolve(["", null]);
    }
    try {
      const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
      const contents = yield vault.cachedRead(templateFile);
      const IFoldInfo = window.app.foldManager.load(templateFile);
      return [contents, IFoldInfo];
    } catch (err) {
      console.error(`Failed to read the daily note template '${templatePath}'`, err);
      new import_obsidian.Notice("Failed to read the daily note template");
      return ["", null];
    }
  });
}

// obsidian-daily-notes-interface-fork/parse.ts
function getDateUID(date, granularity = "day") {
  const ts = date.clone().startOf(granularity).format();
  return `${granularity}-${ts}`;
}
function removeEscapedCharacters(format) {
  return format.replace(/\[[^\]]*\]/g, "");
}
function isFormatAmbiguous(format, granularity) {
  if (granularity === "week") {
    const cleanFormat = removeEscapedCharacters(format);
    return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
  }
  return false;
}
function getDateFromFile(file, granularity) {
  return getDateFromFilename(file.basename, granularity);
}
function getDateFromFilename(filename, granularity) {
  const getSettings2 = {
    day: getDailyNoteSettings,
    week: getWeeklyNoteSettings,
    month: getMonthlyNoteSettings,
    quarter: getQuarterlyNoteSettings,
    year: getYearlyNoteSettings
  };
  const format = getSettings2[granularity]().format.split("/").pop();
  const noteDate = window.moment(filename, format, true);
  if (!noteDate.isValid()) {
    return null;
  }
  if (isFormatAmbiguous(format, granularity)) {
    if (granularity === "week") {
      const cleanFormat = removeEscapedCharacters(format);
      if (/w{1,2}/i.test(cleanFormat)) {
        return window.moment(filename, format.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""), false);
      }
    }
  }
  return noteDate;
}

// obsidian-daily-notes-interface-fork/daily.ts
var DailyNotesFolderMissingError = class extends Error {
};
function createDailyNote(date) {
  return __async(this, null, function* () {
    const app2 = window.app;
    const { vault } = app2;
    const moment4 = window.moment;
    const { template, format, folder } = getDailyNoteSettings();
    const [templateContents, IFoldInfo] = yield getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = yield getNotePath(folder, filename);
    try {
      const createdFile = yield vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment4().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
        const now = moment4();
        const currentDate = date.clone().set({
          hour: now.get("hour"),
          minute: now.get("minute"),
          second: now.get("second")
        });
        if (calc) {
          currentDate.add(parseInt(timeDelta, 10), unit);
        }
        if (momentFormat) {
          return currentDate.format(momentFormat.substring(1).trim());
        }
        return currentDate.format(format);
      }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format)));
      app2.foldManager.save(createdFile, IFoldInfo);
      return createdFile;
    } catch (err) {
      console.error(`Failed to create file: '${normalizedPath}'`, err);
      new import_obsidian2.Notice("Unable to create new file.");
    }
  });
}
function getDailyNote(date, dailyNotes) {
  var _a;
  return (_a = dailyNotes[getDateUID(date, "day")]) != null ? _a : null;
}
function getAllDailyNotes() {
  const { vault } = window.app;
  const { folder } = getDailyNoteSettings();
  const dailyNotesFolder = vault.getAbstractFileByPath((0, import_obsidian2.normalizePath)(folder));
  if (!dailyNotesFolder) {
    throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
  }
  const dailyNotes = {};
  import_obsidian2.Vault.recurseChildren(dailyNotesFolder, (note) => {
    if (note instanceof import_obsidian2.TFile) {
      const date = getDateFromFile(note, "day");
      if (date) {
        const dateString = getDateUID(date, "day");
        dailyNotes[dateString] = note;
      }
    }
  });
  return dailyNotes;
}

// obsidian-daily-notes-interface-fork/weekly.ts
var import_obsidian3 = __toModule(require("obsidian"));
var WeeklyNotesFolderMissingError = class extends Error {
};
function getDaysOfWeek() {
  const { moment: moment4 } = window;
  let weekStart = moment4.localeData()._week.dow;
  const daysOfWeek = [
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday"
  ];
  while (weekStart) {
    daysOfWeek.push(daysOfWeek.shift());
    weekStart--;
  }
  return daysOfWeek;
}
function getDayOfWeekNumericalValue(dayOfWeekName) {
  return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
}
function createWeeklyNote(date) {
  return __async(this, null, function* () {
    const { vault } = window.app;
    const { template, format, folder } = getWeeklyNoteSettings();
    const [templateContents, IFoldInfo] = yield getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = yield getNotePath(folder, filename);
    try {
      const createdFile = yield vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
        const now = window.moment();
        const currentDate = date.clone().set({
          hour: now.get("hour"),
          minute: now.get("minute"),
          second: now.get("second")
        });
        if (calc) {
          currentDate.add(parseInt(timeDelta, 10), unit);
        }
        if (momentFormat) {
          return currentDate.format(momentFormat.substring(1).trim());
        }
        return currentDate.format(format);
      }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
        const day = getDayOfWeekNumericalValue(dayOfWeek);
        return date.weekday(day).format(momentFormat.trim());
      }));
      window.app.foldManager.save(createdFile, IFoldInfo);
      return createdFile;
    } catch (err) {
      console.error(`Failed to create file: '${normalizedPath}'`, err);
      new import_obsidian3.Notice("Unable to create new file.");
    }
  });
}
function getWeeklyNote(date, weeklyNotes) {
  var _a;
  return (_a = weeklyNotes[getDateUID(date, "week")]) != null ? _a : null;
}
function getAllWeeklyNotes() {
  const weeklyNotes = {};
  if (!appHasWeeklyNotesPluginLoaded()) {
    return weeklyNotes;
  }
  const { vault } = window.app;
  const { folder } = getWeeklyNoteSettings();
  const weeklyNotesFolder = vault.getAbstractFileByPath((0, import_obsidian3.normalizePath)(folder));
  if (!weeklyNotesFolder) {
    throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
  }
  import_obsidian3.Vault.recurseChildren(weeklyNotesFolder, (note) => {
    if (note instanceof import_obsidian3.TFile) {
      const date = getDateFromFile(note, "week");
      if (date) {
        const dateString = getDateUID(date, "week");
        weeklyNotes[dateString] = note;
      }
    }
  });
  return weeklyNotes;
}

// obsidian-daily-notes-interface-fork/monthly.ts
var import_obsidian4 = __toModule(require("obsidian"));
var MonthlyNotesFolderMissingError = class extends Error {
};
function createMonthlyNote(date) {
  return __async(this, null, function* () {
    const { vault } = window.app;
    const { template, format, folder } = getMonthlyNoteSettings();
    const [templateContents, IFoldInfo] = yield getTemplateInfo(template);
    const filename = date.format(format);
    const normalizedPath = yield getNotePath(folder, filename);
    try {
      const createdFile = yield vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
        const now = window.moment();
        const currentDate = date.clone().set({
          hour: now.get("hour"),
          minute: now.get("minute"),
          second: now.get("second")
        });
        if (calc) {
          currentDate.add(parseInt(timeDelta, 10), unit);
        }
        if (momentFormat) {
          return currentDate.format(momentFormat.substring(1).trim());
        }
        return currentDate.format(format);
      }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
      window.app.foldManager.save(createdFile, IFoldInfo);
      return createdFile;
    } catch (err) {
      console.error(`Failed to create file: '${normalizedPath}'`, err);
      new import_obsidian4.Notice("Unable to create new file.");
    }
  });
}
function getMonthlyNote(date, monthlyNotes) {
  var _a;
  return (_a = monthlyNotes[getDateUID(date, "month")]) != null ? _a : null;
}
function getAllMonthlyNotes() {
  const monthlyNotes = {};
  if (!appHasMonthlyNotesPluginLoaded()) {
    return monthlyNotes;
  }
  const { vault } = window.app;
  const { folder } = getMonthlyNoteSettings();
  const monthlyNotesFolder = vault.getAbstractFileByPath((0, import_obsidian4.normalizePath)(folder));
  if (!monthlyNotesFolder) {
    throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
  }
  import_obsidian4.Vault.recurseChildren(monthlyNotesFolder, (note) => {
    if (note instanceof import_obsidian4.TFile) {
      const date = getDateFromFile(note, "month");
      if (date) {
        const dateString = getDateUID(date, "month");
        monthlyNotes[dateString] = note;
      }
    }
  });
  return monthlyNotes;
}

// obsidian-daily-notes-interface-fork/quarterly.ts
var import_obsidian5 = __toModule(require("obsidian"));

// obsidian-daily-notes-interface-fork/yearly.ts
var import_obsidian6 = __toModule(require("obsidian"));

// obsidian-daily-notes-interface-fork/index.ts
function appHasWeeklyNotesPluginLoaded() {
  var _a, _b;
  const { app: app2 } = window;
  if (app2.plugins.getPlugin("calendar")) {
    return true;
  }
  const periodicNotes = app2.plugins.getPlugin("periodic-notes");
  return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.weekly) == null ? void 0 : _b.enabled);
}
function appHasMonthlyNotesPluginLoaded() {
  var _a, _b;
  const { app: app2 } = window;
  const periodicNotes = app2.plugins.getPlugin("periodic-notes");
  return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.monthly) == null ? void 0 : _b.enabled);
}

// src/io/noteCache.ts
var import_obsidian7 = __toModule(require("obsidian"));
function getLogNote() {
  const settings2 = getSettings();
  switch (settings2.logNoteType) {
    case "daily":
      return getDailyNote((0, import_obsidian7.moment)(), getAllDailyNotes());
    case "weekly":
      return getWeeklyNote((0, import_obsidian7.moment)(), getAllWeeklyNotes());
    case "monthly":
      return getMonthlyNote((0, import_obsidian7.moment)(), getAllMonthlyNotes());
  }
}
function createLogNote() {
  return __async(this, null, function* () {
    const settings2 = getSettings();
    switch (settings2.logNoteType) {
      case "daily":
        return yield createDailyNote((0, import_obsidian7.moment)());
      case "weekly":
        return yield createWeeklyNote((0, import_obsidian7.moment)());
      case "monthly":
        return yield createMonthlyNote((0, import_obsidian7.moment)());
    }
  });
}

// src/utils/formatter.ts
function displayNotice(message) {
  const notice = new import_obsidian8.Notice("", 1e4);
  notice.noticeEl.innerHTML = `<b>[Obsidian List Modified]</b><br/>${message}`;
}
function consoleWarn(message) {
  console.warn("[Obsidian List Modified] " + message);
}
function getFormattedOutput(path) {
  var _a;
  const file = app.vault.getAbstractFileByPath(path);
  if (!file) {
    return "- " + path;
  }
  const settings2 = getSettings();
  return settings2.outputFormat.replace("[[link]]", this.app.fileManager.generateMarkdownLink(file, ((_a = getLogNote()) == null ? void 0 : _a.path) || "")).replace(/\[\[name]]/g, file.basename).replace(/\[\[tags]]/g, ((0, import_obsidian8.getAllTags)(this.app.metadataCache.getFileCache(file)) || [""]).map((tag) => "\\" + tag).join(", ")).replace(/\[\[ctime]]/g, (0, import_obsidian8.moment)(file.stat.ctime).format(settings2.timeFormat)).replace(/\[\[mtime]]/g, (0, import_obsidian8.moment)(file.stat.mtime).format(settings2.timeFormat));
}
function getFormattedHeading(heading) {
  return getSettings().appendSpaceAfterHeadings ? heading + "\n\n" : heading + "\n";
}

// src/io/useWarnedState.ts
var userWarned = {};
function useWarnedState() {
  return userWarned;
}

// node_modules/monkey-around/mjs/index.js
function after(promise, cb) {
  return promise.then(cb, cb);
}
function serialize(asyncFunction) {
  let lastRun = Promise.resolve();
  function wrapper(...args) {
    return lastRun = new Promise((res, rej) => {
      after(lastRun, () => {
        asyncFunction.apply(this, args).then(res, rej);
      });
    });
  }
  wrapper.after = function() {
    return lastRun = new Promise((res, rej) => {
      after(lastRun, res);
    });
  };
  return wrapper;
}

// src/io/fileWriter.ts
var writeListsToLogFile = serialize(() => __async(void 0, null, function* () {
  const settings2 = getSettings();
  if (settings2.verboseModeEnabled) {
    console.log("--- Writing tracked files ---");
  }
  const logNote = yield setupLogNote();
  if (!logNote)
    return;
  const fileCache = app.metadataCache.getFileCache(logNote);
  if (fileCache === null) {
    if (settings2.verboseModeEnabled) {
      consoleWarn("File cache is null... ending write process");
    }
    return;
  }
  const headings = fileCache.headings;
  if (!headings) {
    if (settings2.verboseModeEnabled) {
      consoleWarn("Headings not found. Creating and appending notes...");
    }
    yield createHeadingAndAppendContentIfApplicable(logNote);
    return;
  }
  const primaryHeadingIndex = headings.findIndex(({ heading }) => heading === settings2.primaryHeading);
  if (primaryHeadingIndex === -1) {
    yield createHeadingAndAppendContentIfApplicable(logNote);
    if (settings2.verboseModeEnabled) {
      consoleWarn("Headings not found. Creating and appending notes...");
    }
    return;
  }
  for (const heading of headings) {
    console.log(heading.heading + " : " + heading.level);
  }
  const followingHeadingIndex = headings.findIndex((heading, index) => index > primaryHeadingIndex && (heading.level === 2 || heading.level === 1));
  try {
    yield app.vault.process(logNote, (data) => {
      const content = data.split("\n");
      const startPos = headings[primaryHeadingIndex].position.end.line + 1;
      if (headings[followingHeadingIndex]) {
        const endPos = headings[followingHeadingIndex].position.start.line;
        content.splice(startPos, endPos - startPos, getFinalContentBlock());
      } else {
        const endPos = content.length;
        content.splice(startPos, endPos - startPos, getFinalContentBlock());
      }
      return content.join("\n");
    });
  } catch (error) {
    displayNotice("Please update Obsidian to its latest version. If this does not work, see console for details.");
    console.error(error);
  }
}));
function setupLogNote() {
  return __async(this, null, function* () {
    const settings2 = getSettings();
    if (getLogNote()) {
      if (settings2.verboseModeEnabled) {
        consoleWarn("Log note found at: " + getLogNote().path);
      }
      return getLogNote();
    }
    if (settings2.autoCreateLogNote) {
      if (settings2.verboseModeEnabled) {
        consoleWarn("Log note not found, but should be created automatically. Creating now...");
      }
      return yield createLogNote();
    }
    consoleWarn("Log note not found");
    const userHasBeenWarnedFor = useWarnedState();
    if (!userHasBeenWarnedFor.fileNotExisting) {
      displayNotice("Your log file does not exist. Please check your settings.");
      userHasBeenWarnedFor.fileNotExisting = true;
    }
    return null;
  });
}
function createHeadingAndAppendContentIfApplicable(logNote) {
  return __async(this, null, function* () {
    const settings2 = getSettings();
    const userHasBeenWarnedFor = useWarnedState();
    if (settings2.verboseModeEnabled) {
      consoleWarn("Trying to creatr heading and append...");
    }
    if (settings2.autoCreatePrimaryHeading) {
      try {
        yield app.vault.process(logNote, (data) => data + "\n" + getFormattedHeading("## " + settings2.primaryHeading) + getFinalContentBlock());
      } catch (error) {
        displayNotice("Please update Obsidian to its latest version. If this does not work, see console for details.");
        console.error(error);
      }
    } else {
      consoleWarn("Primary heading not found");
      if (!userHasBeenWarnedFor.headingsNotExisting) {
        displayNotice("Your primary heading could not be found in your log note. Please check your settings.");
        userHasBeenWarnedFor.headingsNotExisting = true;
      }
    }
    return;
  });
}
function getFinalContentBlock() {
  const settings2 = getSettings();
  const createdList = [];
  const modifiedList = [];
  const deletedList = [];
  for (const file of settings2.trackedFiles) {
    if (!file.matchesCriteria) {
      continue;
    }
    switch (file.supposedList) {
      case "created":
        if (settings2.separateCreated) {
          createdList.push(getFormattedOutput(file.path));
        } else {
          modifiedList.push(getFormattedOutput(file.path));
        }
        break;
      case "modified":
        modifiedList.push(getFormattedOutput(file.path));
        break;
      case "deleted":
        if (settings2.separateDeleted) {
          deletedList.push(getFormattedOutput(file.path));
        }
        break;
    }
  }
  let finalContentBlock = settings2.appendSpaceAfterHeadings ? "\n" : "";
  if (settings2.separateCreated && createdList.length != 0) {
    finalContentBlock += getFormattedHeading("### " + settings2.createdHeading) + createdList.join("\n") + "\n\n";
  }
  if (modifiedList.length != 0) {
    if (settings2.separateDeleted || settings2.separateCreated) {
      finalContentBlock += getFormattedHeading("### " + settings2.modifiedHeading);
    }
    finalContentBlock += modifiedList.join("\n") + "\n\n";
  }
  if (settings2.separateDeleted && deletedList.length != 0) {
    finalContentBlock += getFormattedHeading("### " + settings2.deletedHeading) + deletedList.join("\n") + "\n";
  }
  return finalContentBlock;
}

// src/io/settings.ts
var plugin;
var settings;
function getSettings() {
  return settings;
}
function saveSettings() {
  return __async(this, null, function* () {
    yield plugin.saveData(settings);
    if (settings.verboseModeEnabled) {
      console.log("OLM settings saved.");
    }
  });
}
function saveSettingsAndWriteTrackedFiles() {
  return __async(this, null, function* () {
    yield saveSettings();
    yield writeListsToLogFile();
  });
}
function initSettings(initPlugin) {
  return __async(this, null, function* () {
    plugin = initPlugin;
    settings = Object.assign({}, DEFAULT_SETTINGS, yield plugin.loadData());
  });
}

// src/io/settingsTab.ts
var ListModifiedSettingTab = class extends import_obsidian9.PluginSettingTab {
  display() {
    const settings2 = getSettings();
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Criteria" });
    new import_obsidian9.Setting(containerEl).setName("Ignored Tags").setDesc("Comma-separated list of tags. If a file has a tag present on this list, it won't be linked to. Leave this blank to disable this feature.").addText((text) => text.setPlaceholder("e.g. #daily, #\u{1F4A1}, #\u{1F527}").setValue(settings2.tags).onChange((value) => __async(this, null, function* () {
      settings2.tags = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    new import_obsidian9.Setting(containerEl).setName("Excluded Folders").setDesc("Comma-separated list of folders that should be excluded. If a file is in a folder present on this list, it won't be linked to. Leave this blank to disable this feature. See the wiki for more details.").addText((text) => text.setPlaceholder("e.g. top folder/nextfolder, another top folder").setValue(settings2.excludedFolders).onChange((value) => __async(this, null, function* () {
      settings2.excludedFolders = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    new import_obsidian9.Setting(containerEl).setName("Ignored Name Text").setDesc("List of text that (case insensitive) should cause a file to be ignored if it contains said text. E.g. ignoring 'ab' will prevent file 'xyz-ab-xyz' from being listed because it contains 'ab.' Leave this blank to disable this feature.").addText((text) => text.setPlaceholder("e.g. sync-conflict (recommended if you use syncthing), some more text").setValue(settings2.ignoredNameContains).onChange((value) => __async(this, null, function* () {
      settings2.ignoredNameContains = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    containerEl.createEl("h2", { text: "Formatting" });
    new import_obsidian9.Setting(containerEl).setName("Output Format").setDesc("The format to output added links. Use [[link]] as a placeholder to represent a link, [[name]] for file name, [[tags]], [[ctime]] for created time, [[mtime]] for modified time.").addText((text) => text.setPlaceholder("e.g. - [[link]] ([[tags]])").setValue(settings2.outputFormat).onChange((value) => __async(this, null, function* () {
      settings2.outputFormat = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    new import_obsidian9.Setting(containerEl).setName("Time Format").setDesc("Format for the [[ctime]] or [[mtime]] placeholders").addText((text) => text.setPlaceholder("e.g. YYYY-MM-DD or HH:mm").setValue(settings2.timeFormat).onChange((value) => __async(this, null, function* () {
      settings2.timeFormat = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    new import_obsidian9.Setting(containerEl).setName("Append Space After Headings").setDesc("Whether to append a blank line after every heading or not.").addToggle((toggle) => toggle.setValue(settings2.appendSpaceAfterHeadings).onChange((value) => __async(this, null, function* () {
      settings2.appendSpaceAfterHeadings = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    containerEl.createEl("h2", { text: "Log note" });
    new import_obsidian9.Setting(containerEl).setName("Create Log Note Automatically If It Does Not Exist").setDesc("If this setting is not turned on, your modified files will not be linked unless you create your log note yourself.").addToggle((toggle) => {
      toggle.setValue(settings2.autoCreateLogNote).onChange((value) => __async(this, null, function* () {
        settings2.autoCreateLogNote = value;
        yield saveSettingsAndWriteTrackedFiles();
      }));
    });
    new import_obsidian9.Setting(containerEl).setName("Log Note Type").setDesc("Requires the Periodic Notes plugin for anything other than daily").addDropdown((dropdown) => {
      dropdown.addOption("daily", "Daily").addOption("weekly", "Weekly (Periodic Notes)").addOption("monthly", "Monthly (Periodic Notes)").setValue(settings2.logNoteType).onChange((value) => __async(this, null, function* () {
        settings2.logNoteType = value;
        yield saveSettingsAndWriteTrackedFiles();
      }));
    });
    new import_obsidian9.Setting(containerEl).setName("Write Interval").setDesc("The interval (in seconds) at which to write your modified files to your daily note. Set to 0 to disable and write to your file ASAP. This is recommended especially if you do not use a sync solution. Please restart Obsidian after changing this value.").addText((text) => text.setPlaceholder("e.g. 30").setValue(String(settings2.writeInterval)).onChange((value) => __async(this, null, function* () {
      settings2.writeInterval = parseInt(value);
      yield saveSettings();
    })));
    containerEl.createEl("h2", { text: "Headings" });
    new import_obsidian9.Setting(containerEl).setName("Automatically Create Primary Heading").setDesc("If this is disabled, the plugin will not work until you create the heading yourself. Please KEEP THIS DISABLED if using the Templater plugin with folder templates.").addToggle((toggle) => {
      toggle.setValue(settings2.autoCreatePrimaryHeading).onChange((value) => __async(this, null, function* () {
        settings2.autoCreatePrimaryHeading = value;
        yield saveSettingsAndWriteTrackedFiles();
      }));
    });
    new import_obsidian9.Setting(containerEl).setName("Primary Heading Name").setDesc(`Name of the heading (without "#", case sensitive) to list modified files under.`).addText((text) => text.setPlaceholder("e.g. Modified Notes").setValue(settings2.primaryHeading).onChange((value) => __async(this, null, function* () {
      settings2.primaryHeading = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    new import_obsidian9.Setting(containerEl).setName("Modified Heading Name").setDesc("Name of the heading (without '#', case sensitive) to list modified files under.").addText((text) => text.setPlaceholder("e.g. Modified Notes").setValue(settings2.modifiedHeading).onChange((value) => __async(this, null, function* () {
      settings2.modifiedHeading = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    new import_obsidian9.Setting(containerEl).setName("Separate Created Files").setDesc("Move created files out of the modified list, into a separate heading.").addToggle((toggle) => toggle.setValue(settings2.separateCreated).onChange((value) => __async(this, null, function* () {
      settings2.separateCreated = value;
      createdHeadingNameSetting.setDisabled(!value);
      yield saveSettingsAndWriteTrackedFiles();
    })));
    const createdHeadingNameSetting = new import_obsidian9.Setting(containerEl).setName("Created Heading Name").setDesc(`Name of the heading (without "#", case sensitive) to list created files under.`).addText((text) => text.setPlaceholder("e.g. Created Notes").setValue(settings2.createdHeading).setDisabled(!settings2.separateCreated).onChange((value) => __async(this, null, function* () {
      settings2.createdHeading = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    new import_obsidian9.Setting(containerEl).setName("Separate Deleted Files").setDesc("Track deleted files in your log note.").addToggle((toggle) => toggle.setValue(settings2.separateDeleted).onChange((value) => __async(this, null, function* () {
      deletedHeadingNameSetting.setDisabled(!value);
      settings2.separateDeleted = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    const deletedHeadingNameSetting = new import_obsidian9.Setting(containerEl).setName("Deleted Heading Name").setDesc(`Name of the heading (without "#", case sensitive) to list deleted files under.`).addText((text) => text.setPlaceholder("e.g. Deleted Notes").setValue(settings2.deletedHeading).setDisabled(!settings2.separateDeleted).onChange((value) => __async(this, null, function* () {
      settings2.deletedHeading = value;
      yield saveSettingsAndWriteTrackedFiles();
    })));
    containerEl.createEl("h2", { text: "Debug" });
    new import_obsidian9.Setting(containerEl).setName("Enable Verbose Mode").setDesc("This is only really needed for plugin support.").addToggle((toggle) => {
      toggle.setValue(settings2.verboseModeEnabled).onChange((value) => __async(this, null, function* () {
        settings2.verboseModeEnabled = value;
        yield saveSettings();
        if (value) {
          displayNotice("Verbose mode enabled. Please open your console to see logs.");
        }
      }));
    });
  }
};

// src/listeners/onMetadataCacheChanged.ts
var import_obsidian10 = __toModule(require("obsidian"));
var onMetadataCacheChanged = serialize((file, _data, cache) => __async(void 0, null, function* () {
  yield writeAndResetIfNewDay();
  const settings2 = getSettings();
  if (file === getLogNote()) {
    return;
  }
  const matchesCriteria = fileMatchesCriteria(file, cache);
  const currFile = settings2.trackedFiles.find(({ path }) => path === file.path);
  if (currFile) {
    currFile.matchesCriteria = matchesCriteria;
  } else {
    settings2.trackedFiles.push({
      path: file.path,
      matchesCriteria,
      supposedList: "modified"
    });
  }
  if (settings2.writeInterval) {
    yield saveSettings();
  } else {
    yield saveSettingsAndWriteTrackedFiles();
  }
}));
function writeAndResetIfNewDay() {
  return __async(this, null, function* () {
    const settings2 = getSettings();
    const lastTrackedDate = (0, import_obsidian10.moment)(settings2.lastTrackedDate);
    const granularity = new Map([
      ["daily", "day"],
      ["weekly", "week"],
      ["monthly", "month"]
    ]).get(settings2.logNoteType);
    if (!lastTrackedDate.isSame((0, import_obsidian10.moment)(), granularity)) {
      displayNotice("New day/week/month detected, writing tracked files and resetting...");
      yield saveSettingsAndWriteTrackedFiles();
      settings2.trackedFiles = [];
      const today = (0, import_obsidian10.moment)().format("YYYY-MM-DD");
      if (settings2.verboseModeEnabled) {
        consoleWarn("New time period detected. Old date: " + lastTrackedDate + ". New date: " + today);
      }
      settings2.lastTrackedDate = today;
      yield saveSettings();
    }
  });
}
function fileMatchesCriteria(file, cache) {
  return !noteTitleContainsIgnoredText(file.basename) && !cacheContainsIgnoredTag(cache) && !pathIsExcluded(file.path);
}
function noteTitleContainsIgnoredText(noteTitle) {
  const settings2 = getSettings();
  const ignoredNameContains = settings2.ignoredNameContains;
  if (!ignoredNameContains)
    return false;
  const ignoredText = ignoredNameContains.replace(/\s/g, "").split(",");
  return ignoredText.some((ignoredText2) => {
    const title = noteTitle.toLowerCase();
    const text = ignoredText2.toLowerCase();
    if (!text) {
      return false;
    }
    return title.includes(text);
  });
}
function cacheContainsIgnoredTag(cache) {
  const settings2 = getSettings();
  const currentFileTags = (0, import_obsidian10.getAllTags)(cache);
  const tags = settings2 == null ? void 0 : settings2.tags;
  if (!tags)
    return false;
  const ignoredTags = tags.replace(/\s/g, "").split(",");
  return ignoredTags.some((ignoredTag) => currentFileTags.includes(ignoredTag));
}
function pathIsExcluded(path) {
  const settings2 = getSettings();
  const excludedFolders = settings2.excludedFolders;
  if (!excludedFolders)
    return false;
  const excludedFolderPaths = excludedFolders.replace(/\s*, | \s*,/, ",").split(",").map((path2) => path2.replace(/^\/|\/$/g, ""));
  const currentFilePath = this.app.vault.getAbstractFileByPath(path).parent.path;
  return excludedFolderPaths.some((excludedFolder) => currentFilePath.startsWith(excludedFolder));
}
var onMetadataCacheChanged_default = onMetadataCacheChanged;

// src/listeners/onVaultDelete.ts
var import_obsidian11 = __toModule(require("obsidian"));
var onVaultDelete = serialize((file) => __async(void 0, null, function* () {
  if (file instanceof import_obsidian11.TFile) {
    const settings2 = getSettings();
    if (settings2.verboseModeEnabled) {
      consoleWarn("File deleted: " + file.path);
    }
    const existingFile = settings2.trackedFiles.find(({ path }) => path === file.path);
    if (existingFile) {
      existingFile.supposedList = "deleted";
      existingFile.matchesCriteria = true;
    } else {
      settings2.trackedFiles.push({
        path: file.path,
        supposedList: "deleted",
        matchesCriteria: true
      });
    }
    if (settings2.writeInterval) {
      yield saveSettings();
    } else {
      yield saveSettingsAndWriteTrackedFiles();
    }
  }
}));
var onVaultDelete_default = onVaultDelete;

// src/listeners/onVaultRename.ts
var import_obsidian12 = __toModule(require("obsidian"));
var onVaultRename = serialize((file, oldPath) => __async(void 0, null, function* () {
  if (file instanceof import_obsidian12.TFile) {
    const settings2 = getSettings();
    if (settings2.verboseModeEnabled) {
      consoleWarn("File renamed: " + file.path);
    }
    settings2.trackedFiles.remove(settings2.trackedFiles.find(({ path }) => path === file.path));
    settings2.trackedFiles.find(({ path }) => path === oldPath).path = file.path;
    yield saveSettingsAndWriteTrackedFiles();
  }
}));
var onVaultRename_default = onVaultRename;

// src/listeners/onVaultCreate.ts
var onVaultCreate = serialize((file) => __async(void 0, null, function* () {
  const settings2 = getSettings();
  if (settings2.verboseModeEnabled) {
    consoleWarn("File created: " + file.path);
  }
  if (file === getLogNote())
    return;
  const existingFile = settings2.trackedFiles.find(({ path }) => path === file.path);
  if (existingFile) {
    existingFile.supposedList = "created";
    existingFile.matchesCriteria = false;
  } else {
    settings2.trackedFiles.push({
      path: file.path,
      supposedList: "created",
      matchesCriteria: false
    });
  }
  if (settings2.writeInterval) {
    yield saveSettings();
  } else {
    yield saveSettingsAndWriteTrackedFiles();
  }
}));
var onVaultCreate_default = onVaultCreate;

// src/main.ts
var ListModified = class extends import_obsidian13.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield initSettings(this);
      const settings2 = getSettings();
      yield this.migrateToTwoPointOne();
      const writeIntervalInMs = settings2.writeInterval * 1e3;
      if (writeIntervalInMs) {
        this.registerInterval(window.setInterval(() => __async(this, null, function* () {
          yield saveSettingsAndWriteTrackedFiles();
        }), writeIntervalInMs));
      }
      this.registerEvent(this.app.metadataCache.on("changed", onMetadataCacheChanged_default));
      this.registerEvent(this.app.vault.on("delete", onVaultDelete_default));
      this.registerEvent(this.app.vault.on("rename", onVaultRename_default));
      this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
        this.registerEvent(this.app.vault.on("create", onVaultCreate_default));
      }));
      this.addSettingTab(new ListModifiedSettingTab(this.app, this));
    });
  }
  migrateToTwoPointOne() {
    return __async(this, null, function* () {
      const settings2 = getSettings();
      if (!settings2.heading) {
        return;
      }
      displayNotice("Migrating to 2.1...");
      settings2.autoCreatePrimaryHeading = settings2.automaticallyCreateDailyNote;
      settings2.automaticallyCreateDailyNote = null;
      settings2.primaryHeading = settings2.heading;
      settings2.heading = null;
      if (typeof settings2.trackedFiles[0] === "string") {
        settings2.trackedFiles = settings2.trackedFiles.map((file) => {
          return {
            path: file,
            supposedList: "modified",
            matchesCriteria: true
          };
        });
      }
      yield saveSettings();
    });
  }
};
