---
doc_type: weread-highlights-reviews
bookId: "33380984"
reviewCount: 4
noteCount: 34
author: 蒋金楠
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/984/33380984/t7_33380984.jpg
readingStatus: 读过
progress: 98%
totalReadDay: 56
readingTime: 18小时29分钟
readingDate: 2020-09-05
isbn: 9787121384622
lastReadDate: 2023-02-14
tags:
  - book
---
# 元数据
> [!abstract] ASP.NET Core 3 框架揭秘（上下册）
> - ![ ASP.NET Core 3 框架揭秘（上下册）|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/984/33380984/t7_33380984.jpg)
> - 书名： ASP.NET Core 3 框架揭秘（上下册）
> - 作者： 蒋金楠
> - 简介： 《ASP.NET Core 3框架揭秘》深入浅出地介绍了ASP.NET Core 基础及实战方面的知识，主要有.NET Core 的基础知识及安装、dotnet 命令、ASP.NET Core 开发工具操作及使用、ASP.NET Core 原理和组件介绍、ASP.NET Core MVC 框架学习、ASP.NET Core Web API 学习和扩展Web API 输出格式，以及.NETCore 单元测试，最后以一个完整的项目结尾，并讲解了项目的发布和部署。他还为想要构建生产解决方案(包括用于移动设备的解决方案)的每个开发人员提供了完整的学习路径。通过这本书你可以学会如何创建新项目并理解其结构、在ASP.NET Core中设置和使用熟悉的MVC应用程序模型、编写控制器类代码来控制请求处理的所有阶段、从控制器提供HTML，或者直接通过Razor页面提供HTML等内容。
> - 出版时间： 2020-03-01 00:00:00
> - ISBN： 9787121384622
> - 分类： 计算机-理论知识
> - 出版社： 电子工业出版社
> - PC地址：https://weread.qq.com/web/reader/05a3269071fd5a7805abdcf

# 高亮划线

### 1.1 Windows平台

> 📌 一个运行的ASP.NET Core应用本质上体现为由一个服务器和若干中间件构成的消息处理管道，服务器解决针对 HTTP 请求的监听、接收和最终的响应，具体针对请求的处理则由它递交给后续的中间件来完成。 
> ⏱ 2020-09-05 22:26:07 ^33380984-5-7852-7952

> 📌 launchSettings.json 文件中的所有设置仅仅针对开发环境，在产品环境下是不需要这个文件的，应用发布后生成的文件列表中也不包含该文件。该文件不需要手动编辑，当前项目属性对话框（通过在解决方案对话框中右击选择“Properties”（属性）选项来打开）中“Debug”（调试）选项卡下的所有设置最终都会体现在该文件上（见图1-8）。 
> ⏱ 2020-09-06 23:05:00 ^33380984-5-12716-12888

> 📌 整个 ASP.NET MVC框架建立在 EndpointRoutingMiddleware中间件和 EndpointMiddleware中间件构建的路由系统上，这两个中间件采用“终结点（Endpoint）映射”的方式实现针对HTTP请求的路由 
> ⏱ 2020-09-06 23:10:14 ^33380984-5-16682-16803

> 📌 对于一个MVC应用程序来说，我们可以将定义在Controller类型中的Action方法视为一个终结点，那么路由映射最终体现在HTTP请求与目标Action方法的映射上。 
> ⏱ 2020-09-06 23:11:09 ^33380984-5-16923-17008

### 2.1 历史的枷锁

> 📌 CLR与.NET的关系等同于JVM与Java的关系，CLR本质上就是.NET虚拟机。作为一个运行时（Runtime），CLR 为程序的执行提供一个托管（Managed）的执行环境，它是.NET Framework 的执行引擎，为托管程序的执行提供内存分配、垃圾回收、安全控制、异常处理和多线程管理等方面的服务。 
> ⏱ 2020-09-07 08:06:54 ^33380984-10-1616-1771

> 📌 一方面，BCL 总是作为一个不可分割的整体被加载；另一方面，其自身的尺寸也在随着.NET Framework的升级而不断膨胀。对于客户端应用（如 Windows Forms/WPF应用）来说，这个问题可以忽略，但是对于运行在移动设备和服务器上的应用（包括部署于云端应用）来说，由此带来的对性能和吞吐量的响应就成了一个不得不考虑的问题。 
> ⏱ 2020-09-07 08:11:33 ^33380984-10-4419-4586

> 📌 按照 CLI 的规定，用来描述可执行代码的是一种被称为 CIL（Common Intermediate Language）的语言，这是一种介于高级语言和机器语言之间的中间语言。 
> ⏱ 2020-09-07 08:36:45 ^33380984-10-6831-6919

> 📌 微软制定的 CTS（Common Type System）为CLI确立了一个统一的类型系统。 
> ⏱ 2020-09-07 08:39:36 ^33380984-10-7135-7181

> 📌 CIL实际上是一种面向虚拟机的语言。 
> ⏱ 2020-09-07 13:04:47 ^33380984-10-7629-7647

> 📌 微软为此制定了CLI，然后提交给欧洲计算机制造商协会（European Computer Manufacturers Association，ECMA），成为一个编号为335的规范，所以CLI又被称为ECMA-335。 
> ⏱ 2020-09-07 08:41:31 ^33380984-10-8075-8184

> 📌 综上所述，由于.NET是建立在CLI规范之上的，所以它具有跨平台的“基因”。 
> ⏱ 2020-09-07 08:47:29 ^33380984-10-10176-10214

### 3.1 控制反转

> 📌 总的来说，IoC是设计框架所采用的一种基本思想，所谓的控制反转就是将应用对流程的控制转移到框架之中。 
> ⏱ 2020-09-07 13:35:07 ^33380984-14-3419-3469

### 3.2 IoC模式

> 📌 一般来讲，设计模式提供了一种解决某种具体问题的方案，但 IoC 既没有一个针对性的问题领域，其自身也没有提供一种可操作的解决方案，所以我们更加倾向于将 IoC 视为一种设计原则。很多设计模式都采用了 IoC 原则，下面介绍几种典型的设计模式。 
> ⏱ 2020-09-07 13:37:15 ^33380984-15-506-627

### 3.3 依赖注入

> 📌 依赖注入容器和Service Locator实际上是同一事物在不同设计模式中的不同称谓。 
> ⏱ 2020-09-07 13:51:57 ^33380984-16-7086-7130

> 📌 从某种意义上讲，当我们在程序中使用 IServiceProvider （表示依赖注入容器）提取某个服务实例时，就意味着我们已经在使用 Service Locator 模式了，所以遇到这种情况时应该思考是否一定需要这么做。 
> ⏱ 2020-09-07 13:54:14 ^33380984-16-8304-8414

### 5.2 设计详解

> 📌 从字面上理解，IChangeToken对象就是一个与某组监控数据相关联的“令牌”（Token），它能够在检测到数据改变时及时对外发出一个通知。 
> ⏱ 2021-08-31 09:08:23 ^33380984-26-771-842

### 6.4 配置的同步

> 📌 对于 IConfiguration接口的 GetReloadToken方法返回的 IChangeToken对象，其作用不是在配置源发生变化时向应用程序发送通知，而是通知应用程序：配置源已经发生改变，并且新的数据已经被相应的 IConfigurationProvider 对象重新加载进来。 
> ⏱ 2021-08-29 23:31:34 ^33380984-32-2279-2423

> 📌 通过上面提供的代码我们可以看到，RaiseChanged 方法在两个地方被调用：第一，在构造函数中调用每个IConfigurationProvider对象的 GetReloadToken方法，得到对应的 IChangeToken对象，并在它们注册的回调中调用这个方法；第二，实现的Reload方法在依次调用每个 IConfigurationProvider对象的Load 方法来重新加载配置数据之后，调用了 RaiseChanged方法。按照这个逻辑，应用程序会在如下两个场景中利用ConfigurationRoot返回的IChangeToken接收配置被重新加载的通知。● 某个 IConfigurationProvider 对象捕捉到对应配置源的改变后自动重新加载配置，并在加载完成后利用其GetReloadToken方法返回的IChangeToken发送通知。● 显式调用ConfigurationRoot的Reload方法手动加载配置。 
> ⏱ 2021-08-29 23:49:00 ^33380984-32-3919-4384

### 7.2 Options模型

> 📌 反省 ^33380984-36-7997-7999
- 💭 勘误，应为”泛型“ - ⏱ 2021-11-26 15:45:29 

### 7.3 依赖注入

> 📌 所以通过 IOptions＜TOptions＞接口获取的 Options对象在整个应用的生命周期内都是一致的，而通过 IOptionsSnapshot＜TOptions＞接口获取的 Options 对象则只能在当前请求上下文中保持一致。这也是后者命名的由来，它表示针对当前请求的Options快照。 
> ⏱ 2021-11-26 16:01:14 ^33380984-37-6097-6246

### 10.1 服务承载

> 📌 将配置文件的“Copy to output directory”属性设置为“Copy always”，这样可以确保它在编译时总是被复制到目标目录。 
> ⏱ 2020-09-07 23:17:57 ^33380984-50-6579-6652

> 📌 从名称可以看出，ConfigureAppConfiguration方法的目的在于初始化应用程序所需的配置。 
> ⏱ 2020-09-07 23:17:58 ^33380984-50-7058-7111

> 📌 开发（Development）、预发（Staging）和产品（Production）是 3 种典型的部署环境。 
> ⏱ 2020-09-07 23:17:51 ^33380984-50-8405-8460

### 10.2 承载模型

> 📌 一般来说，一个服务承载应用在整个生命周期内只会创建一个IHost对象，启动和关闭应用程序本质上就是启动和关闭作为宿主的 IHost 对象。 
> ⏱ 2020-09-07 23:17:54 ^33380984-51-1933-2002

> 📌 IHostBuilder接口提供了一系列的方法，我们可以利用它们为最终构建的IHost对象做相应的设置，具体的设置主要涵盖两个方面：针对配置系统的设置和针对依赖注入框架的设置。 
> ⏱ 2020-09-07 23:17:53 ^33380984-51-6558-6646

> 📌 但前者最终会合并到后者之中，应用程序最终得到的配置实际上是两者合并的结果。 
> ⏱ 2021-02-16 13:54:33 ^33380984-51-6918-6955

> 📌 IHostEnvironment 接口的ContentRootPath表示的是存放这些内容文件的根目录所在的路径，ContentRootFileProvider属性对应的则是指向该路径的 IFileProvider 对象，我们可以利用它获取目录的层次结构，也可以直接利用它来读取文件的内容。 
> ⏱ 2020-09-07 23:17:57 ^33380984-51-8876-9021

### 10.3 实现原理

> 📌 HostBuilder对象针对Host对象的构建大体可以划分为如下4个步骤。 
> ⏱ 2022-02-23 19:03:17 ^33380984-52-10984-11022

### 11.1 管道式的请求处理

> 📌 ASP.NET Core请求处理管道必须有一个服务器，它是整个管道的“龙头”。 
> ⏱ 2020-12-22 08:27:33 ^33380984-54-3798-3837

> 📌 那么一个Func＜HttpContext，Task＞对象就可以表示处理HttpContext的操作 
> ⏱ 2021-09-01 09:26:23 ^33380984-54-5854-5903

> 📌 具体来说，强类型方式定义的中间件可以注册为任意生命周期模式的服务，但是按照约定定义的中间件则总是一个Singleton服务。 
> ⏱ 2020-12-22 09:04:25 ^33380984-54-11919-11981

### 14.2 处理文件请求

> 📌 基类SharedOptionsBase 定义了请求路径与对应 IFileProvider 对象之间的映射关系（默认为PhysicalFileProvider）。 
> ⏱ 2021-06-11 13:02:13 ^33380984-71-9133-9213

### 19.1 认证、登录与注销

> 📌 认证是一个旨在确定请求访问者真实身份的过程，与认证相关的还有其他两个基本操作——登录和注销。 
> ⏱ 2021-05-28 19:17:23 ^33380984-92-442-488

### 19.2 身份与用户

> 📌 [插图]
   [插图]
   [插图]
   图19-7 IIdentity接口和IPrincipal接口及其实现类型的关系 
> ⏱ 2021-05-29 18:50:29 ^33380984-93-12487

## 第20章 授权

> 📌 认证后的用户体现为一个 ClaimsPrincipal 对象，它携带的声明不仅仅用于描述用户的身份，还携带了上述这些构建授权策略的元素，所以授权实际上就是检查认证用户携带的声明是否与授权策略一致的过程。 
> ⏱ 2021-06-02 09:09:28 ^33380984-96-598-699

# 读书笔记

## 3.3 依赖注入

### 划线评论
> 📌 我们将这个被框架用来提供服务的容器称为依赖注入容器，也有很多人将其称为 IoC 容器，根据前面针对 IoC 的介绍，笔者认为后者不是一个合理的称谓。  ^21860447-7kblu0TdG
    - 💭 同意，每次听到有人说IoC容器，我就知道这个人既不理解IoC，也不理解DI。
    - ⏱ 2020-09-07 13:45:16
   
## 7.2 Options模型

### 划线评论
> 📌 反省  ^21860447-7v6n6vHIA
    - 💭 勘误，应为”泛型“
    - ⏱ 2021-11-26 15:46:00
   
## 10.3 实现原理

### 划线评论
> 📌 如果注册的服务类型为ConsoleLifetime，它会输出前面提及的3条日志。与此同时，Console Lifetime 对象还会注册控制台的按键事件，其目的在于确保在用户按下取消组合键（Ctrl+C）后应用能够被正常关闭。  ^21860447-7G15xp0S9
    - 💭 Ctrl+C退出的实现原理
    - ⏱ 2023-02-14 12:53:47
   
## 19.3 认证模型

### 划线评论
> 📌 完成  ^21860447-7qFgdOAxD
    - 💭 勘误，应为“完整”
    - ⏱ 2021-05-29 19:06:31
   
# 本书评论

