---
doc_type: weread-highlights-reviews
bookId: "26174312"
reviewCount: 0
noteCount: 18
author: 约瑟夫·阿坝哈瑞 本·阿坝哈瑞
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/312/26174312/t7_26174312.jpg
readingStatus: 读完
progress: 100%
totalReadDay: 83
readingTime: 14小时52分钟
readingDate: 2020-04-08
finishedDate: 2020-06-02
isbn: 9787111631347
lastReadDate: 2022-07-13
tags:
  - book
---
# 元数据
> [!abstract] C# 7.0核心技术指南（原书第7版）
> - ![ C# 7.0核心技术指南（原书第7版）|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/312/26174312/t7_26174312.jpg)
> - 书名： C# 7.0核心技术指南（原书第7版）
> - 作者： 约瑟夫·阿坝哈瑞 本·阿坝哈瑞
> - 简介： C# 7.0是Microsoft对其旗舰编程语言的第六次重大升级，这次升级大大提高了C#语言的功能和灵活性。一方面，它提供了一些高级的抽象，例如查询表达式和异步延续；另一方面，它允许通过自定义值类型和可选的指针结构进行底层的效率优化。C#语言特性的增长也极大地加重了我们的学习负担。虽然一些工具如Microsoft IntelliSense和在线参考文档可以为工作提供诸多便利，但若要使用它们仍需要一些现有的概念和知识体系作为支撑。本书以简明统一的方式（而非烦琐冗长的介绍）准确阐释了这些知识。与之前的四个版本一样，本书也是围绕概念和用例来进行组织的。因此无论是顺序阅读还是随意浏览都大有裨益。虽然本书只要求读者具备基本的背景知识，但是它仍然有一定的深度，比较适合中高级读者阅读。
> - 出版时间： 2019-07-01 00:00:00
> - ISBN： 9787111631347
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社
> - PC地址：https://weread.qq.com/web/reader/710327c0718f6368710b285

# 高亮划线

### 14.1 概述

> 📌 ASP.NET、WCF或者Web Services，则.NET Framework会自动执行并行处理。然而，程序员仍然需要关注某些共享的状态（例如使用静态变量作为缓存）。 
> ⏱ 2021-04-22 09:36:41 ^26174312-140-676-761

### 14.2 线程

> 📌 线程是一个可以独立执行的执行路径。 
> ⏱ 2021-04-22 09:57:05 ^26174312-141-420-437

> 📌 而在多线程程序中，一个进程中会运行多个线程。它们共享同一个执行环境（特别是内存）。 
> ⏱ 2020-06-02 11:44:05 ^26174312-141-554-595

> 📌 线程是抢占式的。 
> ⏱ 2021-04-22 10:03:02 ^26174312-141-3167-3175

> 📌 Thread.Sleep(0)将会导致线程立即放弃自己的时间片，自觉地将CPU交于其他的线程。Thread.Yield()执行相同的操作，但是它仅仅会将资源交给同一个处理器上运行的线程。 
> ⏱ 2020-11-24 08:23:28 ^26174312-141-4393-4486

> 📌 阻塞的线程会立刻交出它的处理器时间片，并从此开始不再消耗处理器时间。直至阻塞条件结束。 
> ⏱ 2020-11-24 08:24:53 ^26174312-141-4967-5010

> 📌 当线程被阻塞或者解除阻塞时，操作系统就会进行一次上下文切换（context switch）。这会导致细小的开销，一般在1到2毫秒左右。 
> ⏱ 2021-04-22 10:10:24 ^26174312-141-5863-5930

> 📌 如果一个操作的绝大部分时间都在等待事件的发生，则称为I/O密集，例如下载网页或者调用Console.ReadLine。（I/O密集操作一般都会涉及输入或者输出，但是这并非硬性要求。例如Thread.Sleep也是一种I/O密集的操作）。而相反的，如果操作的大部分时间都用于执行大量的CPU操作，则称为计算密集。 
> ⏱ 2020-11-24 08:26:45 ^26174312-141-6030-6185

> 📌 CLR为每一个线程分配了独立的内存栈，从而保证了局部变量的隔离。 
> ⏱ 2020-11-24 08:55:00 ^26174312-141-7554-7586

> 📌 线程执行和线程创建时所处的try/catch/finally语句块无关。 
> ⏱ 2021-04-22 10:25:45 ^26174312-141-15258-15294

> 📌 · 线程池中的线程都是后台线程。· 阻塞线程池中的线程将影响性能（请参见14.2.13.2）。 
> ⏱ 2020-06-03 07:54:29 ^26174312-141-25653-25729

### 14.3 任务

> 📌 与线程相比，Task是一个更高级的抽象概念，它代表了一个并发操作，而该操作并不一定依赖线程来完成。 
> ⏱ 2021-04-22 11:22:20 ^26174312-142-941-990

> 📌 如果并未提供任何同步上下文，或者调用了ConfigureAwait(false)，延续代码一般会运行在先导任务运行的线程上，从而避免不必要的开销。 
> ⏱ 2021-04-29 09:08:18 ^26174312-142-9678-9751

> 📌 Task.Delay是Thread.Sleep的异步版本。 
> ⏱ 2021-04-30 00:29:50 ^26174312-142-16166-16195

### 14.4 异步原则

> 📌 常用的经验法则是任何超过50毫秒的响应都用异步的方式处理。 
> ⏱ 2020-06-03 22:35:28 ^26174312-143-2397-2426

### 14.5 C#的异步函数

> 📌 await等待的表达式通常情况下是一个任务。但实际上，只要该对象拥有GetAwaiter方法，且该方法的返回值为可等待对象（awaitable object）（这个对象需实现INotify-Completion.OnCompleted方法，具有返回恰当类型的GetResult方法和一个bool类型的IsCompleted属性），则编译器都可以接受。 
> ⏱ 2020-06-04 11:28:43 ^26174312-144-3342-3517

> 📌 异步函数的简洁性：只需按同步方式书写，并当调用异步函数时进行等待（await）就可以避免阻塞了。 
> ⏱ 2020-06-04 11:50:11 ^26174312-144-7241-7289

### 15.2 使用流

> 📌 AppDomain.CurrentDomain.BaseDirectory属性会返回应用程序的基础目录（base directony），正常情况下它就是可执行文件所在的文件夹。 
> ⏱ 2022-07-13 23:41:07 ^26174312-149-10502-10590

# 读书笔记

# 本书评论

