---
doc_type: weread-highlights-reviews
bookId: "621704"
reviewCount: 0
noteCount: 33
author: 张子阳
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/704/621704/t7_621704.jpg
readingStatus: 读完
progress: 100%
totalReadDay: 25
readingTime: 7小时20分钟
readingDate: 2019-08-18
finishedDate: 2021-09-30
isbn: 9787111445326
lastReadDate: 2022-07-22
tags:
  - read

---
# 元数据
> [!abstract] .NET之美：.NET关键技术深入解析
> - ![ .NET之美：.NET关键技术深入解析|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/704/621704/t7_621704.jpg)
> - 书名： .NET之美：.NET关键技术深入解析
> - 作者： 张子阳
> - 简介： 
> - 出版时间： 2015-01-01 00:00:00
> - ISBN： 9787111445326
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社
> - PC地址：https://weread.qq.com/web/reader/39c328b0597c8839cfa6f27

# 高亮划线

## 第一部分 C#语言基础

> 📌 值类型和引用类型是以它们在计算机内存中是如何被分配的来划分的。 
> ⏱ 2022-07-19 09:05:47 ^621704-4-951-982

> 📌 之所以说是“隐式地”，是因为在C#代码中，是看不到这个继承关系的，这个关系只有通过MSIL代码才可以看到。System.ValueType类型和所有的引用类型都继承自System.Object基类。 
> ⏱ 2022-07-19 09:06:13 ^621704-4-1255-1354

> 📌 栈（stack）是一种后进先出的数据结构，在内存中，变量会被分配在栈上来进行操作。堆（heap）是用于为引用类型的实例（对象）分配空间的内存区域，在堆上创建一个对象，会将对象的地址传给栈上的变量（反过来叫变量指向此对象，或者变量引用此对象）。 
> ⏱ 2022-07-19 09:07:10 ^621704-4-1485-1606

> 📌 编译器隐式地为结构类型创建无参数的构造函数。在这个构造函数中会对结构成员进行初始化，所有的值类型成员被赋予0或相当于0的值，所有的引用类型被赋予null值。（因此，Struct类型不可以自行声明无参数的构造函数）。所以，可以通过隐式声明的构造函数去创建一个ValPoint类型变量： 
> ⏱ 2022-07-19 09:10:48 ^621704-4-3974-4115

> 📌 装箱就是将一个值类型转换成等价的引用类型。 
> ⏱ 2022-07-19 09:14:55 ^621704-4-8638-8659

### 第3章 C#中的委托和事件

> 📌 Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。 
> ⏱ 2019-08-19 08:55:03 ^621704-6-4432-4466

> 📌 委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else（Switch）语句，同时使程序具有更好的可扩展性。 
> ⏱ 2019-08-19 08:56:32 ^621704-6-5498-5599

> 📌 在采用接口实现时，利用的是C#的多态能力。 
> ⏱ 2019-08-19 17:17:43 ^621704-6-10293-10314

> 📌 声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。 
> ⏱ 2019-08-19 17:24:52 ^621704-6-15032-15063

> 📌 尽管直接使用委托变量通常不会有什么问题，但它给了客户端不应具有的能力，而使用事件，可以限制这一能力，更精确地对类型进行封装。 
> ⏱ 2019-08-19 17:31:08 ^621704-6-17382-17444

> 📌 实际上MakeGreet会被编译成私有字段 
> ⏱ 2019-08-19 17:32:17 ^621704-6-17848-17869

> 📌 很多的委托定义返回值都为void，为什么呢？这是因为委托变量可以供多个订阅者注册，如果定义了返回值，那么多个订阅者的方法都会向发布者返回数值，结果就是后面一个返回的方法值将前面的返回值覆盖掉了，因此，实际上只能获得最后一个方法调用的返回值。 
> ⏱ 2019-08-21 10:24:04 ^621704-6-28589-28709

### 第5章 LINQ

> 📌 为了解决这个问题，.NET框架3.5版本引入了一项新的技术—LINQ。 
> ⏱ 2019-12-16 13:20:08 ^621704-8-704-739

> 📌 LINQ的全称是语言集成查询（Language Integrated Query） 
> ⏱ 2019-12-12 23:37:50 ^621704-8-824-865

> 📌 在离散数学中，有一个术语叫做谓词（Predicate），谓词就是一个判定，要么为真要么为假。类似地，在.NET中，接收一个参数并返回bool类型的方法也可以称为一个谓词。 
> ⏱ 2019-12-12 23:41:58 ^621704-8-2919-3004

> 📌 在LINQ中使用到的另一个关键技术就是扩展方法（Extension Method），它也是从C#3.0开始才新添的功能。 
> ⏱ 2019-12-12 23:49:56 ^621704-8-8609-8669

> 📌 匿名方法是在C#2.0中引入的。在C#3.0中，又引入了一种Lambda表达式的语法，可以将它视为匿名方法的等价物，但是语法更为简洁，使得匿名方法的编写变得更加方便。 
> ⏱ 2019-12-13 08:03:36 ^621704-8-16005-16088

## 第二部分 .NET框架

> 📌 CIL（Common Intermediate Language，公共中间语言） 
> ⏱ 2019-12-16 21:32:39 ^621704-9-4728-4768

> 📌 FCL了（Framework Class Library，框架类库）。 
> ⏱ 2019-12-16 21:49:48 ^621704-9-12399-12434

> 📌 CTS（Common Type System 
> ⏱ 2019-12-16 22:29:51 ^621704-9-13172-13194

> 📌 CLS（Common Language Specification，公共语言规范） 
> ⏱ 2019-12-16 22:29:51 ^621704-9-16925-16966

> 📌 .NET框架的核心部分：CLR（Common Language Runtime），公共语言运行时） 
> ⏱ 2019-12-16 22:29:52 ^621704-9-18892-18941

> 📌 CLI是一个国际标准，由ECMA和ISO进行了标准化，全称为Common Language Infrastructure（公共语言基础）。它只是一个概念和汇总，实际上本章的每一小节都是这个标准的一部分。CLI包括：CIL、CTS、CLS、VES、元数据、基础框架。 
> ⏱ 2019-12-16 22:29:50 ^621704-9-24202-24334

### 第7章 程序集

> 📌 将程序集安装到GAC之后，就可以对它进行引用了。大家知道，.NET框架下的程序集都是安装到GAC中的，比如System.Data。 
> ⏱ 2019-12-18 09:08:39 ^621704-10-29982-30047

> 📌 在开发和编译阶段，使用的是C：\Program Files\Reference Assemblies\路径下的程序集，而在运行阶段，则使用的是GAC（C：\Windows\Assembly）下的程序集。 
> ⏱ 2019-12-18 09:08:36 ^621704-10-30386-30487

> 📌 这是引用GAC程序集与引用非强名称程序集的一个重要区别：不会复制一份ClassLib.dll的副本到应用程序根目录。 
> ⏱ 2019-12-18 09:08:38 ^621704-10-31088-31146

### 第8章 流和序列化

> 📌 将每8位定义为一个字节（Byte） 
> ⏱ 2022-07-22 09:15:12 ^621704-11-1872-1889

> 📌 流的最主要用途就是与应用程序外部的文件或数据源进行数据交互。 
> ⏱ 2022-07-22 09:16:47 ^621704-11-4438-4468

> 📌 流与字节数组Byte[]不同，Byte[]是一个静态的数据容器，它本身保存了全部的数据；而流是一个动态的概念，按照字节的次序进行顺序访问，每次可以只访问单个字节，也可以访问连续的一段字节。 
> ⏱ 2022-07-22 09:17:31 ^621704-11-4702-4796

> 📌 因为Byte[]保存的是临时数据，当下次循环时临时数据就会被覆盖并丢弃。Byte[]相当于一个临时缓存，因此通常会将它命名为buffer。 
> ⏱ 2022-07-22 09:19:15 ^621704-11-5254-5323

### 第11章 .NET Remoting

> 📌 只要是跨越应用程序域的对象访问，都属于Remoting，不管这两个应用程序域位于同一进程中，不同进程中，还是不同的计算机上。 
> ⏱ 2019-12-23 00:13:47 ^621704-14-12642-12704

### 第16章 多线程

> 📌 简单来说死锁就是两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，如果没有外力进行干预（例如调用Abort（）方法），则它们都将无法推进下去。 
> ⏱ 2019-12-21 09:56:10 ^621704-19-34191-34273

### 第17章 对象生存期与垃圾收集

> 📌 最容易被清理掉的，就是那些新对象，这些对象往往存在于一个很小的作用域内（例如for循环内，方法内），但数量往往又是最庞大的。通过使用对象分级，可以显著地提高垃圾回收的效率。 
> ⏱ 2021-09-30 09:11:14 ^621704-20-8288-8374

# 读书笔记

# 本书评论

