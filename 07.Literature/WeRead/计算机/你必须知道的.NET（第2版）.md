---
doc_type: weread-highlights-reviews
bookId: "655956"
reviewCount: 1
noteCount: 51
author: 王涛
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/956/655956/t7_655956.jpg
readingStatus: 读过
progress: 97%
totalReadDay: 33
readingTime: 7小时46分钟
readingDate: 2020-04-14
isbn: 9787121141287
lastReadDate: 2021-03-10
tags:
  - book
---
# 元数据
> [!abstract] 你必须知道的.NET（第2版）
> - ![ 你必须知道的.NET（第2版）|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/956/655956/t7_655956.jpg)
> - 书名： 你必须知道的.NET（第2版）
> - 作者： 王涛
> - 简介： 本书分为5个部分，第1部分讲述.NET与面向对象，从底层实现角度分析了.NET如何实现面向对象机制，进一步分析了面向对象设计原则；第2部分论述了.NET类型系统和CLR的内存管理机制，并对IL语言进行了相应介绍；第3部分论述.NET Framework框架的方方面面，详细分析了.NET框架的所有重点、难点和疑点内容，对框架类库的全貌进行了必要的专题性探讨；第4部分重点介绍了.NET泛型和安全性的相关知识和本质解密；第5部分对.NET 3.0/3.5/4.0新特性进行了详细的介绍和引导。
> - 出版时间： 2011-08-01 00:00:00
> - ISBN： 9787121141287
> - 分类： 计算机-编程设计
> - 出版社： 电子工业出版社
> - PC地址：https://weread.qq.com/web/reader/4cd327f05a02544cd77419d

# 高亮划线

### 第1章 OO大智慧

> 📌 当然，有必要补充的是对象中的多态主要包括以下两种情况：·接口实现多态，就像上例所示。·抽象类实现多态，就是以抽象类来实现。 
> ⏱ 2020-04-15 08:26:16 ^655956-8-5729-5850

> 📌 GC管理所有的托管堆对象，当内存回收执行时，GC检查托管堆中不再被使用的对象，并执行内存回收操作。不被应用程序使用的对象，指的是对象没有任何引用。 
> ⏱ 2020-04-15 08:28:21 ^655956-8-6315-6388

#### 1.2 什么是继承

> 📌 继承机制体现了面向对象技术中的复用性、扩展性和安全性。 
> ⏱ 2020-04-15 08:46:22 ^655956-9-2521-2548

> 📌 CLR支持实现单继承和接口多继承。 
> ⏱ 2020-04-15 08:47:50 ^655956-9-2897-2914

> 📌 这种在子类中实现虚函数的方式，称为方法的动态绑定，是实现面向对象另一特性：多态的基本机制。 
> ⏱ 2020-04-15 08:50:08 ^655956-9-3507-3552

> 📌 在此我们以Chicken对象的创建为例，首先是字段，对象一经创建，会首先找到其父类Bird，并为其字段分配存储空间，而Bird也会继续找到其父类Animal，为其分配存储空间，依次类推直到递归结束，也就是完成System.Object内存分配为止。 
> ⏱ 2020-04-17 18:29:58 ^655956-9-5551-5675

> 📌 然后，是方法表的创建，必须明确的一点是方法表的创建是类第一次加载到AppDomain时完成的，在对象创建时只是将其附加成员TypeHandle指向方法列表在Loader Heap上的地址，将对象与其动态方法列表相关联起来，因此方法表是先于对象而存在的。 
> ⏱ 2020-04-15 08:55:24 ^655956-9-5853-5979

> 📌 子类不光继承父类的公有成员，同时继承了父类的私有成员，只是在子类中不被访问。 
> ⏱ 2020-04-15 11:42:24 ^655956-9-6914-6952

> 📌 答案是“Type is Chicken”，根据上面的分析，想想到底为什么？
   2.关于new关键字在虚方法动态调用中的阻断作用，也有了更明确的理论基础。在子类方法中，如果标记new关键字，则意味着隐藏基类实现，其实就是创建了与父类同名的另一个方法，在编译中这两个方法处于动态方法表的不同地址位置，父类方法排在前面，子类方法排在后面。 
> ⏱ 2020-04-15 18:40:36 ^655956-9-8236

> 📌 ·接口着重于CAN-DO关系类型，而抽象类则偏重于IS-A式的关系。·接口多定义对象的行为；抽象类多定义对象的属性。 
> ⏱ 2020-04-15 18:42:23 ^655956-9-8839-8927

> 📌 聚合关系是一种HAS-A式的关系 
> ⏱ 2020-04-15 18:44:04 ^655956-9-10196-10212

> 📌 面向对象的基本原则多聚合，少继承。低耦合，高内聚。 
> ⏱ 2020-04-15 18:47:48 ^655956-9-11316-11403

#### 1.3 封装的秘密

> 📌 字段（field）通常定义为private，表示类的状态信息。CLR支持只读和读写字段。值得注意的是，大部分情况下字段都是可读可写的，只读字段只能在构造函数中被赋值，其他方法不能改变只读字段。 
> ⏱ 2020-04-16 08:48:17 ^655956-10-3956-4052

#### 1.4 多态的艺术

> 📌 多态分为四类：强制的、重载的、参数的和包含的。本节可以理解为包含的多态，从面向对象的角度来看，根据其实现的方式我们可以进一步分为基类继承式多态和接口实现式多态。 
> ⏱ 2020-04-16 13:57:28 ^655956-11-10356-10436

> 📌 从技术实现角度来看，是.NET的动态绑定机制成就了面向对象的多态特性。 
> ⏱ 2020-04-16 13:58:24 ^655956-11-11333-11368

#### 1.5 玩转接口

> 📌 实现了接口的类方法在IL标记为override，表示覆写了接口方法实现，因此接口的抽象机制仍然是多态来完成的。接口在本质上，仍旧是一个不能实例化的类，但是又区别于一般意义上的类，例如不能实例化、允许多继承、可以作用于值类型等。 
> ⏱ 2020-04-16 14:06:03 ^655956-12-4492-4605

> 📌 设计模式的师祖GoF，有句名言：Program to an interface, not an implementation，表示对接口编程而不要对实现编程，更通俗的说法是对抽象编程而不要对具体编程。 
> ⏱ 2020-04-16 14:07:28 ^655956-12-5906-6006

### 第3章 OO之美

> 📌 SOA、Mapper、Pipeline、DTO、Message Bus 
> ⏱ 2020-04-20 00:30:15 ^655956-21-6599-6634

#### 3.2 依赖的哲学

> 📌 控制反转（Inversion of Control，IoC），简言之就是代码的控制器交由系统控制，而不是在代码内部，通过IoC，消除组件或者模块间的直接依赖，使得软件系统的开发更具柔性和扩展性。控制反转的典型应用体现在框架系统的设计上，是框架系统的基本特征，不管是.NET Framework抑或是Java Framework都是建立在控制反转的思想基础之上。 
> ⏱ 2020-04-20 08:44:36 ^655956-22-18881-19061

> 📌 依赖注入（Dependency Injection，DI），早见于Martin Flower的Inversion of Control Containers and the Dependency Injection pattern一文，其定义可概括为：客户类依赖于服务类的抽象接口，并在运行时根据上下文环境，由其他组件（例如DI容器）实例化具体的服务类实例，将其注入到客户类的运行时环境，实现客户类与服务类实例之间松散 的耦合关系。 
> ⏱ 2020-04-20 08:46:32 ^655956-22-19669-19914

#### 3.4 面向对象和基于对象

> 📌 举个例子，我们基本认为C#是面向对象的语言，而JavaScript是基于对象的语言。 
> ⏱ 2020-04-21 08:53:32 ^655956-24-1509-1551

> 📌 总结而言，面向对象与基于对象，二者的概念主要体现在：· 继承是区别面向对象与基于对象的核心所在，对于少了继承性的基于对象来说，自然少了多态性支持。· 封装是面向对象与基于对象的共同特征。 
> ⏱ 2020-04-21 08:54:46 ^655956-24-2020-2173

#### 3.6 好代码和坏代码

> 📌 Martin Fowler说：任何一个傻瓜都可以写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀程序员。 
> ⏱ 2020-04-21 08:59:37 ^655956-26-677-736

#### 4.2 教你认识IL代码——从基础到工具

> 📌 最典型的编译与反编译利器就是.NET Framework自带的ILASM.exe和ILDASM.exe工具 
> ⏱ 2020-04-21 13:09:11 ^655956-30-975-1028

#### 4.5 经典指令解析之实例创建

> 📌 值类型在编译期已经在栈上分配好了内存。 
> ⏱ 2020-04-21 13:38:00 ^655956-33-3493-3512

### 第5章 品味类型

> 📌 [插图]
   图5-1 公共语言架构
   5.1.2 基本概念
   还是老套路，首先引入MSDN对通用类型系统的定义，通用类型系统定义了如何在运行库中声明、使用和管理类型，同时也是运行库支持跨语言集成的一个重要组成部分。通用类型系统执行以下功能： 
> ⏱ 2020-05-27 22:18:42 ^655956-36-1210

> 📌 可以简单地说，基于.NET的语言共同使用一个类型系统，这就是CTS。
   进一步的探讨通用类型系统的内容，我们知道CTS支持两种基本的类型，每种类型又可以细分出其下级子类，如图5-2所示。
   数组类型枚举类型
   [插图]
   图5-2 类型体系图（图片来源：MSDN） 
> ⏱ 2020-05-27 22:18:43 ^655956-36-2727

#### 5.2 品味类型——值类型与引用类型

> 📌 值类型（Value Type），值类型实例通常分配在线程的堆栈（stack）上，并且不包含任何指向实例数据的指针，因为变量本身就包含了其实例数据。 
> ⏱ 2020-05-29 08:38:19 ^655956-37-1181-1254

> 📌 。值类型主要包括简单类型、结构体类型和枚举类型等。 
> ⏱ 2020-05-29 08:38:11 ^655956-37-1299-1324

> 📌 string类型是个特殊的引用类型，具有Immutability特性，因此每次对string的改变都会在托管堆中产生一个新的string变量。另外，string类型重载了==操作符，比较的是实际的字符串，而不是引用地址 
> ⏱ 2020-05-29 08:56:40 ^655956-37-6110-6219

> 📌 值类型与引用类型之间的转换过程称为装箱与拆箱 
> ⏱ 2020-06-08 08:47:14 ^655956-37-7136-7158

> 📌 Richter就称值类型为“轻量级”类型，简直恰如其分，处理数据较小的情况时，应该优先考虑值类型。 
> ⏱ 2020-06-08 08:53:17 ^655956-37-7656-7705

### 第7章 深入浅出——关键字的秘密

> 📌 string strA = new string（'*', 100）； 
> ⏱ 2021-02-26 18:57:30 ^655956-47-5597-5634

#### 7.2 base和this

> 📌 尽量少用或者不用base和this。除了决议子类的名称冲突和在一个构造函数中调用其他的构造函数之外，base和this的使用容易引起不必要的结果。 
> ⏱ 2021-03-01 08:56:44 ^655956-48-7119-7192

#### 7.3 using的多重身份

> 📌 显然，编译器自动将using生成为try-finally语句，并在finally块中调用对象的Dispose方法，来清理资源。 
> ⏱ 2021-03-01 09:04:05 ^655956-49-6019-6082

> 📌 using语句适用于清理单个非托管资源的情况，而多个非托管对象的清理最好以try-finally来实现，因为嵌套的using语句可能存在隐藏的Bug 
> ⏱ 2021-03-01 09:05:40 ^655956-49-6840-6914

> 📌 Dispose方法用于清理对象封装的非托管资源，而不是释放对象的内存，对象的内存永远由垃圾回收器控制。 
> ⏱ 2021-03-01 09:07:06 ^655956-49-8103-8154

#### 7.4 认识全面的null

> 📌 可空类型是内置于CLR的，所以它并非C#的独门绝技，VB.NET中也存在相同的概念。 
> ⏱ 2021-03-02 08:55:53 ^655956-50-4397-4439

#### 7.7 非主流关键字

> 📌 因此定义密封方法时sealed必须和override同时使用。密封方法可以覆写基类的方法，但其本身不可在子类中覆写。 
> ⏱ 2021-03-04 09:14:53 ^655956-53-11721-11779

> 📌 密封类一个常见的应用就是：当一个类只有静态成员时，可以考虑将其实现为密封类，例如.NET框架中的System.Math、System.Drawing.Pen等。 
> ⏱ 2021-03-04 09:16:00 ^655956-53-12215-12295

#### 8.5 恩怨情仇：is和as

> 📌 任何类型都可以安全地转换为其基类类型，可以由隐式转换来完成。·任何类型转换为其派生类型时，必须进行显式转换，转换的规则是：（类型名）对象名； 
> ⏱ 2021-03-08 13:54:20 ^655956-59-938-1087

> 📌 值类型和引用类型的转换机制称为装箱（boxing）和拆箱 
> ⏱ 2021-03-08 13:54:42 ^655956-59-1273-1301

> 📌 通常来说，is用于进行类型判断，而as用于类型转型。 
> ⏱ 2021-03-08 13:56:29 ^655956-59-2955-2981

#### 8.7 有深有浅的克隆：浅拷贝和深拷贝

> 📌 浅拷贝（Shallow Copy），指对象的字段被拷贝，而字段引用的对象不会被拷贝，拷贝对象和源对象仅仅是引用名称有所不同，但是它们共用一份实体。对任何一个对象的更改，都会影响到另一个对象。大部分的引用类型，实现的都是浅拷贝，引用类型对象之间的赋值，就是复制一个对象引用地址的副本，而指向的对象实例仍然是同一个。 
> ⏱ 2021-03-08 14:01:35 ^655956-62-1458-1614

> 📌 深拷贝（Deep Copy），指对象的字段被拷贝，同时字段引用的对象也进行了拷贝。深拷贝创建的是整个源对象的结构，拷贝对象和源对象相互独立，不共享任何实例数据，修改一个对象不会影响到另一个对象。显然，值类型之间的赋值操作，执行的就是深拷贝。 
> ⏱ 2021-03-08 14:02:17 ^655956-62-2249-2369

#### 8.9 集合通论

> 📌 按照集合类型实现的接口来分，集合主要分为：有序集合、索引集合和键式集合。有序集合，主要是指仅实现了ICollection接口的集合类，如Stack和Queue；索引集合，主要是指实现了IList接口的集合类，如Array、ArrayList等；键式集合主要是指实现了IDictionary接口的集合类，如Hashtable。 
> ⏱ 2021-03-09 09:10:52 ^655956-64-7989-8151

#### 9.5 如此特殊：大话String

> 📌 应用上，String类型表现为值类型语义；内存上，String类型实现为引用类型，存储在托管堆中。 
> ⏱ 2021-02-20 08:57:33 ^655956-70-1027-1076

> 📌 简单地说，string就是char[] 
> ⏱ 2021-02-20 09:01:05 ^655956-70-4125-4144

> 📌 字符串一旦创建，就会在托管堆上分配一块连续的内存空间，我们对其的任何改变都不会影响到原String对象 
> ⏱ 2021-02-22 08:59:55 ^655956-70-6223-6274

> 📌 其原因还是源于字符串的恒定性，因为是不可变的，所以根本没有必要再隔离。 
> ⏱ 2021-02-23 08:56:54 ^655956-70-12568-12603

> 📌 Convert方法在str为null时不会抛出异常，而是返回0。 
> ⏱ 2021-02-26 23:59:58 ^655956-70-13481-13513

#### 9.6 简易不简单：认识枚举

> 📌 所有枚举类型都隐式而且只能隐式地继承自System.Enum类型，System.Enum类型是继承自System.ValueType类型唯一不为值类型的引用类型。 
> ⏱ 2021-03-10 08:57:29 ^655956-71-1237-1318

> 📌 枚举类型是值类型，分配于线程的堆栈上，自动继承于Enum类型，但是本身不能被继承；Enum类型是引用类型，分配于托管堆上，Enum类型本身不是枚举类型，但是提供了操作枚举类型的共用方法。 
> ⏱ 2021-03-10 09:00:31 ^655956-71-1891-1984

> 📌 枚举定义时可以声明其基础类型，例如本例Week枚举的基础类型指明为int型，默认情况时即为int。 
> ⏱ 2021-03-10 09:04:04 ^655956-71-4324-4373

# 读书笔记

## 1.2 什么是继承

### 划线评论
> 📌 随着继承层次的复杂化和子类的多样化，不可避免地会出现对父类的无效继承或者有害继承。子类部分的继承父类的方法或者属性，更能适应实际的设计需求。  ^21860447-7gD6l0Nlp
    - 💭 继承不可避免地会破坏封装性。
    - ⏱ 2020-04-15 18:46:29
   
# 本书评论

